"""
P2：Cookie 请求头可观测一致性（与 cookiejar_1903 解耦）。

目的：
- 验证在相同 cookiefile 输入下，QCurl 与 libcurl baseline 发出的 Cookie: 头在服务端视角一致

服务端：repo 内置 http_observe_server.py（/cookie）
基线：repo 内置 qcurl_lc_http_baseline（--cookiefile）
QCurl：tst_LibcurlConsistency（p2_cookie_request_header）
"""

from __future__ import annotations

import os
import uuid
from pathlib import Path
from typing import Dict, List

import pytest

from tests.libcurl_consistency.pytest_support.artifacts import build_request_semantic, write_json
from tests.libcurl_consistency.pytest_support.baseline import run_libtest_case
from tests.libcurl_consistency.pytest_support.compare import assert_artifacts_match
from tests.libcurl_consistency.pytest_support.observed import observe_http_observed_for_id
from tests.libcurl_consistency.pytest_support.qcurl_runner import run_qt_test
from tests.libcurl_consistency.pytest_support.service_logs import collect_service_logs_for_case, should_collect_service_logs


def _append_req_id(url: str, req_id: str) -> str:
    sep = "&" if "?" in url else "?"
    return f"{url}{sep}id={req_id}"


def _seed_cookiefile(path: Path, host: str) -> None:
    content = "\n".join([
        "# Netscape HTTP Cookie File",
        "# https://curl.se/docs/http-cookies.html",
        "# This file was generated by libcurl! Edit at your own risk.",
        "",
        f"{host}\tFALSE\t/\tFALSE\t0\tfoo\tbar",
        f"{host}\tFALSE\t/\tFALSE\t0\tbaz\tqux",
        "",
    ])
    path.write_text(content, encoding="utf-8")


def _normalize_cookie_header(raw: str) -> str:
    parts = [p.strip() for p in (raw or "").split(";")]
    parts = [p for p in parts if p]
    parts.sort()
    return "; ".join(parts)


def test_p2_cookie_request_header(env, lc_services, lc_logs, lc_observe_http, tmp_path):
    qt_bin = os.environ.get("QCURL_QTTEST")
    qt_path = Path(qt_bin).resolve() if qt_bin else None
    if not qt_path or not qt_path.exists():
        pytest.skip("QCURL_QTTEST 未设置或可执行不存在")

    collect_logs = should_collect_service_logs()
    port = int(lc_observe_http["port"])
    observe_log = Path(str(lc_observe_http["log_file"]))

    suite = "p2_cookie_header"
    proto = "http/1.1"
    case_variant = "lc_cookie_request_header_http_1.1"

    trace_base = f"lc_{uuid.uuid4().hex[:8]}_cookie_header"
    baseline_req_id = f"{trace_base}__baseline"
    qcurl_req_id = f"{trace_base}__qcurl"

    url = f"http://localhost:{port}/cookie"
    baseline_url = _append_req_id(url, baseline_req_id)

    baseline_cookie = tmp_path / "baseline.cookies"
    qcurl_cookie = tmp_path / "qcurl.cookies"
    _seed_cookiefile(baseline_cookie, "localhost")
    _seed_cookiefile(qcurl_cookie, "localhost")

    req_meta = {"method": "GET", "url": baseline_url, "headers": {}, "body": b""}
    resp_meta = {"status": 200, "http_version": proto, "headers": {}, "body": None}

    try:
        observe_log.write_text("", encoding="utf-8")
        baseline = run_libtest_case(
            env=env,
            suite=suite,
            case=case_variant,
            client_name="cli_lc_http",
            args=[
                "-V",
                proto,
                "--cookiefile",
                str(baseline_cookie),
                baseline_url,
            ],
            request_meta=req_meta,
            response_meta=resp_meta,
            download_count=1,
        )

        obs = observe_http_observed_for_id(observe_log, baseline_req_id)
        cookie_norm = _normalize_cookie_header(obs.headers.get("cookie", ""))
        req_headers = dict(obs.headers)
        req_headers["cookie"] = cookie_norm
        baseline["payload"]["request"] = build_request_semantic(
            obs.method,
            obs.url,
            req_headers,
            b"",
        )
        baseline["payload"]["response"]["status"] = obs.status
        baseline["payload"]["response"]["http_version"] = proto
        baseline["payload"]["response"]["headers"] = obs.response_headers
        write_json(baseline["path"], baseline["payload"])

        observe_log.write_text("", encoding="utf-8")
        qcurl_url = _append_req_id(url, qcurl_req_id)
        qcurl = run_qt_test(
            env=env,
            suite=suite,
            case=case_variant,
            qt_executable=qt_path,
            args=[],
            request_meta={"method": "GET", "url": qcurl_url, "headers": {}, "body": b""},
            response_meta=resp_meta,
            download_count=1,
            case_env={
                "QCURL_LC_CASE_ID": "p2_cookie_request_header",
                "QCURL_LC_PROTO": proto,
                "QCURL_LC_REQ_ID": qcurl_req_id,
                "QCURL_LC_COOKIE_PATH": str(qcurl_cookie),
                "QCURL_LC_OBSERVE_HTTP_PORT": str(port),
            },
        )

        obs = observe_http_observed_for_id(observe_log, qcurl_req_id)
        cookie_norm = _normalize_cookie_header(obs.headers.get("cookie", ""))
        req_headers = dict(obs.headers)
        req_headers["cookie"] = cookie_norm
        qcurl["payload"]["request"] = build_request_semantic(
            obs.method,
            obs.url,
            req_headers,
            b"",
        )
        qcurl["payload"]["response"]["status"] = obs.status
        qcurl["payload"]["response"]["http_version"] = proto
        qcurl["payload"]["response"]["headers"] = obs.response_headers
        write_json(qcurl["path"], qcurl["payload"])

        assert_artifacts_match(baseline["path"], qcurl["path"])
    except Exception:
        if collect_logs:
            collect_service_logs_for_case(
                env,
                suite=suite,
                case=case_variant,
                logs=lc_logs,
                meta={
                    "case_id": "p2_cookie_request_header",
                    "case_variant": case_variant,
                    "proto": proto,
                    "baseline_req_id": baseline_req_id,
                    "qcurl_req_id": qcurl_req_id,
                    "observe_http_port": port,
                },
            )
        raise

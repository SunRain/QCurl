"""
P1：cookie file/jar 一致性（LC-10）。

基线：lib1903（COOKIEFILE -> easy_reset -> COOKIEFILE+COOKIEJAR）
QCurl：cookiejar_1903（ReadOnly -> ReadWrite）

说明：QCurl 当前只暴露单一路径（cookie file path 同时用于 jar），因此 baseline 也使用同一路径作为输出。
"""

from __future__ import annotations

import os
import uuid
from pathlib import Path
from typing import Dict, List

import pytest

from tests.libcurl_consistency.pytest_support.artifacts import sha256_bytes, write_json
from tests.libcurl_consistency.pytest_support.baseline import run_libtest_case
from tests.libcurl_consistency.pytest_support.compare import assert_artifacts_match
from tests.libcurl_consistency.pytest_support.observed import httpd_observed_for_id
from tests.libcurl_consistency.pytest_support.qcurl_runner import run_qt_test


def _append_req_id(url: str, req_id: str) -> str:
    sep = "&" if "?" in url else "?"
    return f"{url}{sep}id={req_id}"


def _seed_cookiefile(path: Path, host: str) -> None:
    content = "\n".join([
        "# Netscape HTTP Cookie File",
        "# https://curl.se/docs/http-cookies.html",
        "# This file was generated by libcurl! Edit at your own risk.",
        "",
        f"{host}\tFALSE\t/we/want/\tFALSE\t0\tsecondcookie\tpresent",
        f"{host}\tFALSE\t/we/want/\tFALSE\t0\tfoobar\tname",
        "",
    ])
    path.write_text(content, encoding="utf-8")


def _normalize_cookiejar(path: Path) -> List[str]:
    lines = path.read_text(encoding="utf-8", errors="replace").splitlines()
    raw_records = [ln.strip() for ln in lines if ln.strip() and not ln.startswith("#")]

    def normalize_record(rec: str) -> str:
        # Netscape cookie format:
        # domain \t flag \t path \t secure \t expires \t name \t value
        parts = rec.split("\t")
        if len(parts) < 7:
            return rec
        cookie_path = parts[2]
        if cookie_path.endswith("/") and cookie_path != "/":
            cookie_path = cookie_path[:-1]
        parts[2] = cookie_path
        return "\t".join(parts)

    return sorted(normalize_record(r) for r in raw_records)


def _cookiejar_payload(records: List[str]) -> Dict[str, object]:
    joined = "\n".join(records).encode("utf-8")
    return {
        "records": records,
        "sha256": sha256_bytes(joined),
    }


def test_p1_cookiejar_1903(env, lc_services, lc_logs, tmp_path):
    qt_bin = os.environ.get("QCURL_QTTEST")
    qt_path = Path(qt_bin).resolve() if qt_bin else None
    if not qt_path or not qt_path.exists():
        pytest.skip("QCURL_QTTEST 未设置或可执行不存在")

    proto = "http/1.1"
    trace_base = f"lc_{uuid.uuid4().hex[:8]}_cookiejar_1903"
    baseline_req_id = f"{trace_base}__baseline"
    qcurl_req_id = f"{trace_base}__qcurl"

    url = f"http://localhost:{env.http_port}/we/want/1903"
    baseline_url = _append_req_id(url, baseline_req_id)

    baseline_cookie = tmp_path / "baseline.cookies"
    qcurl_cookie = tmp_path / "qcurl.cookies"
    _seed_cookiefile(baseline_cookie, "localhost")
    _seed_cookiefile(qcurl_cookie, "localhost")

    req_meta = {
        "method": "GET",
        "url": baseline_url,
        "headers": {},
        "body": b"",
    }
    resp_meta = {
        "status": 200,
        "http_version": proto,
        "headers": {},
        "body": None,
    }

    suite = "p1_cookies"
    case_variant = "lc_cookiejar_1903_http_1.1"

    try:
        baseline = run_libtest_case(
            env=env,
            suite=suite,
            case=case_variant,
            client_name="lib1903",
            args=[baseline_url, str(baseline_cookie), str(baseline_cookie)],
            request_meta=req_meta,
            response_meta=resp_meta,
        )
    except FileNotFoundError as exc:
        pytest.skip(f"libtests 未构建: {exc}")

    access_log = Path(lc_logs["httpd_access_log"])
    obs = httpd_observed_for_id(access_log, baseline_req_id, require_range=False)
    assert obs.http_version == proto
    baseline["payload"]["request"]["method"] = obs.method
    baseline["payload"]["request"]["url"] = obs.url
    baseline["payload"]["request"]["headers"] = obs.headers
    baseline["payload"]["response"]["status"] = obs.status
    baseline["payload"]["response"]["http_version"] = obs.http_version
    baseline_records = _normalize_cookiejar(baseline_cookie)
    baseline["payload"]["cookiejar"] = _cookiejar_payload(baseline_records)
    write_json(baseline["path"], baseline["payload"])

    case_env = {
        "QCURL_LC_CASE_ID": "cookiejar_1903",
        "QCURL_LC_PROTO": proto,
        "QCURL_LC_HTTP_PORT": str(env.http_port),
        "QCURL_LC_HTTPS_PORT": str(env.https_port),
        "QCURL_LC_WS_PORT": str(env.ws_port),
        "QCURL_LC_COUNT": "1",
        "QCURL_LC_DOCNAME": "",
        "QCURL_LC_UPLOAD_SIZE": "0",
        "QCURL_LC_ABORT_OFFSET": "0",
        "QCURL_LC_FILE_SIZE": "0",
        "QCURL_LC_REQ_ID": qcurl_req_id,
        "QCURL_LC_COOKIE_PATH": str(qcurl_cookie),
    }

    qcurl = run_qt_test(
        env=env,
        suite=suite,
        case=case_variant,
        qt_executable=qt_path,
        args=[],
        request_meta=req_meta,
        response_meta=resp_meta,
        download_files=None,
        download_count=None,
        case_env=case_env,
    )

    obs = httpd_observed_for_id(access_log, qcurl_req_id, require_range=False)
    assert obs.http_version == proto
    qcurl["payload"]["request"]["method"] = obs.method
    qcurl["payload"]["request"]["url"] = obs.url
    qcurl["payload"]["request"]["headers"] = obs.headers
    qcurl["payload"]["response"]["status"] = obs.status
    qcurl["payload"]["response"]["http_version"] = obs.http_version
    qcurl_records = _normalize_cookiejar(qcurl_cookie)
    qcurl["payload"]["cookiejar"] = _cookiejar_payload(qcurl_records)
    write_json(qcurl["path"], qcurl["payload"])

    assert len(baseline_records) == 2
    assert set(baseline_records) == set(qcurl_records)

    assert_artifacts_match(baseline["path"], qcurl["path"])
